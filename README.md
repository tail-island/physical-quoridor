# 課題とコンクールの進め方

フランス産ボードゲームの[Quoridor](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%AA%E3%83%89%E3%83%BC%E3%83%AB)を物理エンジン上に実装したゲーム、Physical QuoridorをプレイするAIを作成してください。

## ルール

敵よりも早く、自分の駒をゴールに到達させてください。駒を移動させる際は、地面がとても滑りやすいことに気を付けてください。滑って盤面から墜ちても負けになります。駒を移動させる以外にも、フェンスを設置して敵を妨害することができます。

![]()

### アクション

ステップ毎に、自分と敵で同時にアクションを実施します。アクションは、自分の駒に力を加えるか、フェンスを設置するかのどちらかです。

アクションの指示は、アクションの種類（自分の駒に力を加える=0、フェンスを設置する=1）と、駒に加えるX方向の力、駒に加えるY方向の力、フェンスを設置する縦位置、フェンスを設置する横位置、設置するフェンスの向きの5つです。

![]()

#### 駒に力を加える

駒の座標系は以下の通りです。

![]()

駒に対してX方向に加える力と、Y方向に加える力を指示してください。数値であればどんな値（精度は単精度浮動小数点数）でも指定できますが、実際に駒に加えられる力の大きさは0.5以下に制限されます。例えば、X方向に1.0、Y方向に1.0を設定しても、右上45°の方向に[tex:{\sqrt{2}}]の力**ではなく**、0.5の大きさの力が加えられます。

![]()

駒に力を加える際には、力の大きさに応じたランダムな値の力も加えられます。同じ力を加えた場合でも、わずかではありますが異なる結果になることに注意してください。

#### フェンスを設置する

フェンスの位置は以下の通りです。駒の座標系と上下が逆であることに気を付けてください。

![]()

設置するフェンスの向きは、水平（0）と垂直（1）があります。駒がゴールできなくなる位置や、他のフェンスと重なる位置には設置できません（エラーにはなりません。単にフェンスが設置されないだけです）。自分と敵が重なる位置にフェンスを設置しようとした場合は、ランダムに選ばれたどちらか片方のフェンスが設置されます。

![]()

設置可能なフェンスの枚数は、10枚までです。また、フェンスは連続では設置できません。次にフェンスを設置できるのは、フェンス設置の10ステップ後以降となります。

### 報酬

ゲームが終了すると、以下の表を上から調べ、マッチした行の報酬が与えらます。

| プレイヤー0が<br>ゴールした | プレイヤー1が<br>ゴールした | プレイヤー0が<br>盤面から落ちた | プレイヤー1が<br>盤面から落ちた | プレイヤー0の報酬 | プレイヤー1の報酬 |
| :--: | :--: | :--: | :--: | ---: | ---: |
|   |   | Y | Y | -0.5 | -0.5 |
|   |   | Y | N | -1.0 |  1.0 |
|   |   | N | Y |  1.0 | -1.0 |
| Y | Y |   |   |  0.5 |  0.5 |
| Y | N |   |   |  1.0 | -1.0 |
| N | Y |   |   | -1.0 |  1.0 |

また、ゴールしたり盤面から落ちたりしていない場合でも、1,200ステップ実行で終了となります。その場合の報酬はどちらのプレイヤーも0.0です。

## 対戦環境

対戦環境はPython上で動作します。Pythonをインストールし、[ソースコード](./physical-quoridor.zip)を解凍し、以下を実行してください。

1. `cd .\physical-quoridor`
2. `pip install .\physical_quoridor-0.1.0-cp313-cp313-win_amd64.whl`                   # Pythonのバージョンが3.13の場合。3.12の場合は、`pip install .\physical_quoridor-0.1.0-cp313-cp313-win_amd64.whl`としてください。
3. `cd .\game`
4. `python .\play.py "プレイヤー0を起動するコマンド" "プレイヤー1を起動するコマンド"`  # サンプルのプレイヤーで実行するなら、`python .\play.py "python ..\sample-players\sample_player.py" "python ..\sample-players\strict_shortest_path_player.py"`としてください。

実行速度を一定にしたい場合は`--wait`オプションを、乱数シードを指定したい場合は`--seed 乱数シード`オプションを指定してください。

``python .\play.py "python ..\sample-players\sample_player.py" "python ..\sample-players\strict_shortest_path_player.py" --wait --seed 1`

AIの標準エラー出力はplayer-0.logとlayer-1.logに保存されます。開発の際にご使用ください。

ゲームのログはgame.logに出力されます。game.logを使用してゲームを再生したいときは、`python .\replay.py`を実行してください。

## 作成していただくプログラムの仕様

作成していただくプログラムは、対戦環境からの指示を標準入力から受信し、対戦環境への応答を標準出力に送信しなければなりません。送受信データのフォーマットはJSONで、1つのデータを1行で表現します。

プログラムが処理しなければならない通信は、アクション指示とゲーム終了の2種類です。

### アクション指示

入力は`{"command":"get_action","observation":[自分の駒の位置,敵の駒の位置,自分の駒の速度,敵の駒の速度,フェンスの設置状況,自分の残りフェンス数,敵の残りフェンス数,自分がフェンス設置可能になるまでのステップ数,敵がフェンス設置可能になるまでのステップ数]}`です。

駒の位置は`[X座標,Y座標]`で、駒の速度は`[速度のX軸方向の成分,速度のY軸方向の成分]`、フェンスの設置状況は、縦位置（0～7）×横位置（0～7）×水平（0）または垂直（1）の、8×8×2の多次元配列（フェンスが設置されている場合の値は1、そうでなければ0）です。

フェンスの設置状況は、.\sample-players\utility.pyの`get_shortest_path()`関数内の`get_fences()`関数のようにNumPyを使用して`zip(*np.where(observation[4]))`でフェンスが設置された縦位置と横位置、フェンスの向きを取得できますし、NumPyを使用したくないなら.\web\src\players\SamplePlayer.jsのように多重ループでも取得できます。

出力は`[アクションの種類（自分の駒に力を加える=0、フェンスを設置する=1）,[駒に加えるX方向の力,駒に加えるY方向の力],[フェンスを設置する縦位置,フェンスを設置する横位置,設置するフェンスの向き]`です。

「アクションの種類」は0または1の整数、「駒に加えるX方向の力」と「駒に加えるY方向の力」は単精度浮動小数点数、「フェンスを設置する縦位置」と「フェンスを設置する横位置」は0～7の整数、「設置するフェンスの向き」は0または1の整数でなければなりません。

アクションの種類が0の場合は`[フェンスを設置する縦位置,フェンスを設置する横位置,設置するフェンスの向き]`が、1の場合は`[駒に加えるX方向の力,駒に加えるY方向の力]`は無視されます（が、ルールに準拠した値を指定しなければなりません）。

### ゲーム終了

入力は`{"command":"end_game"}`です。`"OK"`を標準出力に出力して、プログラムを終了させてください。

### 注意点

* 有償のライブラリやプログラミング言語は使用しないでください。
* 不正なJSONの送付とルールで許されていないアクションが発生した場合は、そのゲームは負けとなります。
* 対戦環境は、OSがWindows 11 Professional 64bitでCPUがIntel(R) Core(TM) Ultra 7 155U、メモリが64GBで、ネットワークからは遮断されています。他の参加者のプログラムも同じコンピューターで実行しますので、アクションの送信が終わった後自分のアクション指示まではCPUを使用しないことと、メモリを使用しすぎないことを遵守してください。また、リクエストがあればGPU（NVIDIA GeForce RTX 4090）をThunderboltで接続します。
* 受信開始から送信完了までの処理は、概ね5秒以内に完了させてください。
* ログの出力には、標準エラー出力を使用してください。標準出力は対戦環境との通信以外では使用できません。

## サンプル

.\sample-playersにPythonで作成したサンプルAIを置きましたので、プログラミング時の参考にしてみてください。

* random_player.py: ランダムに移動もしくはフェンスを設置します。何も考えていません。
* shortest_path_player.py: 盤面を9×9のマスとみなし、上下左右のマスへの移動に限定した場合の最短経路を求め、その経路を進むように駒に力を加えます。慣性を考慮していないので、よく盤面から落ちて負けます。
* strict_shortest_path_player.py: shortest_path_player.pyの発展形で、盤面から落ちないようにゆっくり最短経路を進みます。移動速度が遅くて`--wait`をつけるとイライラします。
* sample_player.py: strict_shortest_path_player.pyに加えて、敵の最短経路を長くする位置にフェンスを設置します。同じ盤面を自分も進むことを考えていないため、自分を苦しめるフェンス設置になることが多くて泣きそうです。

## コンクールの進行

練習試合と公式試合を、それぞれ1回実行します。

練習試合では、ランダムな乱数シードとランダムに選択したプレイヤーでのゲームを72時間繰り返します。報酬の平均をスコアとし、このスコアが大きい順で最終順位を決定します。

練習試合は提出形式やプログラムの動作を参加者が確認するために実施するもので、選考には影響しません。練習試合では、最終順位とゲームおよび標準エラー出力の内容を、プログラムの作成者に公開します。

公式試合では、予選として練習試合と同じ形式の試合を実施し、上位4名を決定します。決勝では、乱数シードを固定した4名の総当たり戦（同じ乱数シードで、4人から2人を選択する順列の12試合）を24時間繰り返して、最終順位を決定します。決勝で同着が発生した場合は、同着同士の総当たり戦を8時間実施して、追加試合での順位の平均で最終順位を決定します。
